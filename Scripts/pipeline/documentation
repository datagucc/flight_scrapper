#pour chaque prix, il faut ajouter des colonnes aggrégées :
- moyenne pour ce voyage
- max pour ce voyage
- min pour ce voyage
- une colonne qui indique une valeur suspecte (si la valeur du prix est differente de 50% que la moyenne, alors il faut le flager et investiguer)



PIPELINE :

1. raw big table : sortie directe de l'OCR, pas de ID ni de transfo, dans le dossier raw : /Users/focus_profond/GIT_repo/flight_price_tracker/Data/raw : OK 
2. bronze : recuperation de la bigtable raw, ajout de l'ID et stockage dans le dossier bronze : pas d'autres transfo. Pas hyper pratique car cela signfie que on devra chaque fois ouvrir la table raw big table dans un DF, ajouter la colonne ID et écrire dans la table big table bronze.  Cependant, on fera un merge sur l'ID pour la table big table bronze : OK 

3. silver : relecture de la table big table bronze (avec l'id), filtre à partir de l'ID, modification, ajout des nouvelles colonnes, insertion incrémentale dans la big table silver.

4. gold : ajout de la big table silver dans la db postgresql + creation des tables aggrégées.
Pour ajouter les données dans la db postgresql, je récupere d'abord le max id de postgresql, je récupère la table deltatable de silver, je la filtre sur l'id et ensuite j'insère les nouvelles données dans la db postgresql. Enfin, je fais un test pour vérifier qu'il n'y a pas de doublons.

5. ajouter une couche d'analyse : ajouter des logs, analyser les logs, analyser quelles sont les trip qui ont le plus d'erreurs,... et adapter mon script en fonction

6. amélorier les performances.

TABLE AGGREGES :
flight_date, flight_price, trip, date_of_search, avg_price, max_price, min_price, flag (from partition of date_of_search)

SELECT
flight_date
,flight_price
,trip
, date_of_search
,avg(cast(flight_price as numeric)) over (partition by flight_date, trip) avg_price_per_date
,max(cast(flight_price as numeric)) over (partition by flight_date, trip) max_price_per_date
,min(cast(flight_price as numeric)) over (partition by flight_date, trip) min_price_per_date
,avg(cast(flight_price as numeric)) over (partition by  trip) avg_price_per_trip
,max(cast(flight_price as numeric)) over (partition by  trip) max_price_per_trip
,min(cast(flight_price as numeric)) over (partition by  trip) min_price_per_trip
	FROM "FPT".big_table
	where flight_price <> 'no_price_founded' and flight_date <> 'no_date_founded'
	order by trip desc;
